package plugin

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"testing"
	"time"

	"github.com/grafana/grafana-plugin-sdk-go/backend"
	"github.com/joho/godotenv"
	"github.com/mark3labs/mcp-go/mcp"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"grafana-mcpclient-datasource/pkg/agent"
	"grafana-mcpclient-datasource/pkg/models"
)

func TestClaudeIntegration(t *testing.T) {
	// Load environment variables from .env file
	err := godotenv.Load("../../.env")
	if err != nil {
		t.Skipf("Skipping Claude integration test: .env file not found (%v)", err)
	}

	// Get Claude configuration from environment
	apiKey := os.Getenv("ANTHROPIC_API_KEY")
	model := os.Getenv("ANTHROPIC_MODEL")

	if apiKey == "" || apiKey == "your-anthropic-api-key-here" {
		t.Skip("Skipping Claude integration test: ANTHROPIC_API_KEY not set in .env file")
	}

	if model == "" {
		model = "claude-3-5-sonnet-20241022"
	}

	t.Logf("Testing with Claude model: %s", model)

	// Test the Claude-powered natural language query functionality
	config := models.MCPDataSourceSettings{
		ServerURL:         "http://localhost:8081",
		Transport:         "sse",
		ConnectionTimeout: 30,
		LLMProvider:       "anthropic",
		LLMModel:          model,
		LLMAPIKey:         apiKey,
	}

	settingsJSON, err := json.Marshal(config)
	require.NoError(t, err)

	settings := backend.DataSourceInstanceSettings{
		JSONData: settingsJSON,
	}

	ctx := context.Background()
	instance, err := NewDatasource(ctx, settings)
	require.NoError(t, err)

	ds, ok := instance.(*Datasource)
	require.True(t, ok)
	defer ds.Dispose()

	testCases := []struct {
		name          string
		query         string
		expectedTool  string
		expectSuccess bool
	}{
		{
			name:          "error logs query",
			query:         "Show me recent error logs",
			expectedTool:  "loki_query",
			expectSuccess: true,
		},
		{
			name:          "warning logs query",
			query:         "Find warning messages from the last hour",
			expectedTool:  "loki_query",
			expectSuccess: true,
		},
		{
			name:          "general log search",
			query:         "Search for database connection issues",
			expectedTool:  "loki_query",
			expectSuccess: true,
		},
		{
			name:          "help query",
			query:         "What can you help me with?",
			expectedTool:  "", // May or may not call a tool
			expectSuccess: true,
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			t.Logf("Testing Claude with query: '%s'", tc.query)

			// Create natural language query
			queryJSON := fmt.Sprintf(`{"queryType": "natural_language", "query": "%s"}`, tc.query)
			dataQuery := backend.DataQuery{
				JSON: json.RawMessage(queryJSON),
			}

			queryCtx, cancel := context.WithTimeout(context.Background(), 60*time.Second) // Longer timeout for API calls
			defer cancel()

			response := ds.query(queryCtx, backend.PluginContext{}, dataQuery)

			if response.Error != nil {
				t.Logf("Query error: %v", response.Error)
				if tc.expectSuccess {
					t.Errorf("Expected success but got error: %v", response.Error)
				}
				return
			}

			if !tc.expectSuccess {
				t.Errorf("Expected error but query succeeded")
				return
			}

			assert.NoError(t, response.Error)
			assert.NotEmpty(t, response.Frames)

			t.Logf("Claude query '%s' returned %d frames", tc.query, len(response.Frames))

			// Verify the main result frame
			if len(response.Frames) > 0 {
				mainFrame := response.Frames[0]
				assert.Equal(t, "natural_language_result", mainFrame.Name)
				assert.True(t, len(mainFrame.Fields) >= 4)

				// Extract and log the summary generated by Claude
				for _, field := range mainFrame.Fields {
					if field.Name == "summary" && field.Len() > 0 {
						if summary, ok := field.At(0).(string); ok {
							t.Logf("Claude generated summary: %s", summary)
						}
					}
				}

				// Check metadata
				assert.NotNil(t, mainFrame.Meta)
				assert.NotNil(t, mainFrame.Meta.Custom)
				if customMap, ok := mainFrame.Meta.Custom.(map[string]interface{}); ok {
					assert.Equal(t, "natural_language", customMap["queryType"])
				}
			}

			// Check if expected tool was called (if specified)
			if tc.expectedTool != "" && len(response.Frames) > 1 {
				toolCallFrame := response.Frames[1]
				if toolCallFrame.Name == "tool_calls" && len(toolCallFrame.Fields) > 0 {
					toolNameField := toolCallFrame.Fields[0]
					if toolNameField.Name == "tool_name" && toolNameField.Len() > 0 {
						if toolName, ok := toolNameField.At(0).(string); ok {
							assert.Equal(t, tc.expectedTool, toolName)
							t.Logf("Claude correctly selected tool: %s", toolName)

							// Log the reasoning
							if len(toolCallFrame.Fields) > 1 {
								reasoningField := toolCallFrame.Fields[1]
								if reasoningField.Name == "reasoning" && reasoningField.Len() > 0 {
									if reasoning, ok := reasoningField.At(0).(string); ok {
										t.Logf("Claude's reasoning: %s", reasoning)
									}
								}
							}
						}
					}
				}
			}

			// Log information about all frames
			for i, frame := range response.Frames {
				t.Logf("Frame %d: %s with %d fields", i, frame.Name, len(frame.Fields))
				for j, field := range frame.Fields {
					t.Logf("  Field %d: %s (len=%d)", j, field.Name, field.Len())
				}
			}
		})
	}
}

func TestClaudeDirectIntegration(t *testing.T) {
	// Load environment variables from .env file
	err := godotenv.Load("../../.env")
	if err != nil {
		t.Skipf("Skipping Claude direct test: .env file not found (%v)", err)
	}

	// Get Claude configuration from environment
	apiKey := os.Getenv("ANTHROPIC_API_KEY")
	model := os.Getenv("ANTHROPIC_MODEL")

	if apiKey == "" || apiKey == "your-anthropic-api-key-here" {
		t.Skip("Skipping Claude direct test: ANTHROPIC_API_KEY not set in .env file")
	}

	if model == "" {
		model = "claude-3-5-sonnet-20241022"
	}

	t.Logf("Testing Claude directly with model: %s", model)

	// Test Claude provider directly
	provider, err := agent.NewAnthropicProvider(apiKey, model)
	require.NoError(t, err)

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// Test simple response generation
	t.Run("simple_response", func(t *testing.T) {
		prompt := "Explain what a log query tool does in one sentence."
		response, err := provider.GenerateResponse(ctx, prompt)
		require.NoError(t, err)
		assert.NotEmpty(t, response)
		t.Logf("Claude response: %s", response)
	})

	// Test tool selection
	t.Run("tool_selection", func(t *testing.T) {
		// Mock MCP tools
		tools := []mcp.Tool{
			{
				Name:        "loki_query",
				Description: "Query Grafana Loki for log data using LogQL",
			},
		}

		query := "Show me error logs from the last hour"
		toolCall, err := provider.GenerateToolCall(ctx, query, tools)
		require.NoError(t, err)

		if toolCall != nil {
			assert.Equal(t, "loki_query", toolCall.ToolName)
			assert.NotEmpty(t, toolCall.Reasoning)
			t.Logf("Claude selected tool: %s", toolCall.ToolName)
			t.Logf("Claude reasoning: %s", toolCall.Reasoning)
			t.Logf("Claude arguments: %+v", toolCall.Arguments)
		} else {
			t.Log("Claude determined no tool was needed")
		}
	})
}
